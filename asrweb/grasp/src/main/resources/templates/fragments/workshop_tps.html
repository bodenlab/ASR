<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</head>
<body>
<div th:fragment="workshop_tps" class="panel panel-default" aria-expanded="false" id="workshop_tps">
    <div class="content-section-b" id="workshop-div">
        <div class="container">
            <div class="row">
                <div class="col-xs-12">
                    <h2 id="Getting-Started" class="section-heading">Reconstructing Terpene synthases: an illustrative example of using GRASP and associated programs</h2>
                    <h3>Recommended software</h3>
                    <p>
                        <ul>
                        <li>MAFFT - Multiple sequence Alignment (MSA) based on the Fast Fourier Transform (FFT). See Katoh and Standley (2013).</li>
                        <li>Clustal Omega - Multiple Sequence Alignment (tool that is based on profile hidden Markov models and scales well to many thousands of protein sequences. See Sievers and Higgins (2018). We are <i>not</i> using Clustal Omega below.</li>
                        <li>FastTree - Phylogenetic tree inference tool that processes very large numbers of sequences. See Price et al. (2010).</li>
                        <li>Archaeopteryx - Phylogenetic tree visualisation tool that manages to display very large trees. See Han and Zmasek (2009).</li>
                        <li>AliView - Alignment inspection tool. See Larsson (2014).</li>
                        </ul>
                    </p>
                    <h3>Pre-requisites</h3>
                    <div class="step">
                        <h4>Install required software</h4>
                        <p>MAFFT (<a href="https://mafft.cbrc.jp/alignment/software/">https://mafft.cbrc.jp/alignment/software/</a>) and FastTree (<a href="http://www.microbesonline.org/fasttree/">http://www.microbesonline.org/fasttree/</a>) are command-line programs for aligning sequences and inferring a phylogenetic tree.
                            If you do not have these already, install the software on your machine using the instructions found on the websites for your operating system. There are many alternative programs that can be used for the same purpose. See <a href="http://grasp.scmb.uq.edu.au/guide">the guide</a> for some suggestions.</p>
                        <p>Archaeopteryx can be found here: <a href="https://sites.google.com/site/cmzmasek/home/software/archaeopteryx">https://sites.google.com/site/cmzmasek/home/software/archaeopteryx</a>. <a href="http://tree.bio.ed.ac.uk/software/figtree/">Figtree</a> is a capable alternative for visualising phylogenetic trees.</p>
                        <p>AliView can be found here: <a href="http://ormbunkar.se/aliview/">http://ormbunkar.se/aliview/</a>.</p>
                    </div>
                    <div class="step">
                        <h4>Prepare the use of Python</h4>
                        <p>
                            binfpy is a Python library we have developed for doing simple bioinformatics tasks; we are using it below to automate some of the data processing and data analysis.
                            Before trying to install and use it, you need to have Python and git installed on your system. You may have them already, but if not, here's what you need to do:
                        </p>
                        <ul>
                            <li>Install Python 3 or later, with standard data science libraries (NumPy, SciPy and Matplotlib); we recommend <a href="https://www.anaconda.com">the Anaconda distribution</a> which has everything you need and will work with most operating systems</li>
                            <li>Install git; check out <a href="https://www.atlassian.com/git/tutorials/install-git">this guide</a></li>
                        </ul>
                        <p>Once Python and git are on your system, you can setup binfpy. The following command will download it and place it in a directory called "binfpy".</p>
                        <p class="code-style"><pre><code>git clone http://bioinf1.scmb.uq.edu.au/opensource/binfpy.git</code></pre></p>
                        <p>Next you add this directory to your PYTHONPATH system variable; how you do this will depend on your operating system. In MacOS/Linux, you can do it like so:</p>
                        <p class="code-style"><pre><code>export PYTHONPATH=$PYTHONPATH:$PWD/binfpy/src</code></pre></p>
                        <p>You should now be ready to use Python and binfpy as per the examples below.</p>
                    </div>
                    <div class="step">
                        <h3>Collate sequence data, establish homology and infer phylogenetic relationships</h3>
                        <div class="step">
                            <h4>Find and download sequences</h4>
                            <p>There are at least two principal ways of creating a data set from which you can infer ancestor proteins.
                                <ul>
                                <li>Search for potential homologs similar (in sequence) to a specified query protein or set of proteins; typically, this would involve using BLASTp for one or more proteins of specific interest</li>
                                <li>Extract all homologs for a specified and defined family or sub-family from one or more databases; this can involve the use of Uniprot's query interface and subsequent filtering</li>
                                </ul>
                            </p>
                            <p>Terpene synthases are involved in the pathways for generating chemically complex compounds know as terpenes, which naturally occur in plants.
                                These enzymes together make up a protein superfamily, sometimes referred to as class I terpene synthases, in contrast to class II terpene <i>cyclases</i>, which are of less concern here (see the literature for more).
                                There is interest to understand the origins of terpenes, and if novel terpene synthases have the capacity to create novel terpenes and/or with greater efficiency.
                                The following steps highlight the scope of extant terpene synthases and establish their (potential) evolutionary origins;
                                when viewed jointly, the sequence composition of ancestor terpenes synthases may highlight what parts are important and which can be tinkered with.
                                At the outset, it needs to be noted that determining homology between terpene synthases is non-trivial with sequence alone.
                            </p>
                            <p>The Uniprot web interface can be used to extract all reviewed, terpene synthases, using the following query</p>
                            <p class="code-style"><pre><code>family:"terpene synthase family"</code></pre></p>
                            <p>As at 3 June 2019, there are 340 reviewed, and 6168 unreviewed proteins that are deemed members of this family.
                                To limit the time required for data processing, we will primarily analyse the reviewed members. (They are typically of good quality, after having passed Uniprot's review processes.)
                                In general, it is important to consider the value of using unreviewed data, to increase coverage and biological variation.
                                Also of note is that we include bacterial members, including CotB2 (Uniprot ID <a href="https://www.uniprot.org/uniprot/C9K1X5">C9K1X5</a>).
                                If you wanted to only include eukaryotic members, amend the query above to say:
                            </p>
                            <p class="code-style"><pre><code>taxonomy:"Eukaryota [2759]" AND family:"terpene synthase family"</code></pre></p>
                            <p>The next couple of instructions are optional and meant to illustrate what you can do if you wanted to complete the whole process yourself; the final set of files are provided later.
                                If you decide to download them yourself, save them as FASTA files and call them tpswb_reviewed.fa and tpswb_unreviewed.fa, respectively. (wb means "with bacterial".)
                                In fact, using the Uniprot web page, you can edit the query to your liking.
                                While we are at it, also save a file with all TPSs, regardless of review status, as tpswb_all.fa.
                            </p>
                            <p>Bohlmann et al. (1998) identifies six sub-families of plant terpene synthases: tpsa, tpsb, tpsc, tpsd, tpse and tpsf.
                                We will use these to inform our approach so you can download a few more files from querying Uniprot about them; for example
                            </p>
                            <p class="code-style"><pre><code>family:"terpene synthase family tpsa subfamily" AND reviewed:yes</code></pre></p>
                            <p>Download it as a FASTA file; for now call it tpsa.fa. Repeat this process for each subfamily.</p>
                        </div>
                    </div>
                    <div class="step">
                        <h4>Annotate extant sequences</h4>
                        <p>While this step is optional, it may help interpreting some of the outputs below.
                            We will be dealing with hundreds (or even thousands) of sequences, so it is useful to have access to additional information about them when available when looking at them collectively.
                        </p>
                        <p>We have developed a simple-to-use web tool <a href="http://bioinf.scmb.uq.edu.au/seqscrub">SeqScrub</a> that can enrich any FASTA file with taxonomic information available from NCBI.
                            <a href="http://bioinf.scmb.uq.edu.au/seqscrub">SeqScrub</a> can also check if your data set has sequences that are out-of-date or contain invalid characters;
                            this latter functionality is especially useful if you are scraping data from older databases.
                        </p>
                        <p>
                            In our case we have other specialised information about the sequence data, like the subfamily to which sequences belong.
                            For such tasks, there may not be a public tool that can help us; instead we write some Python code to add this information to our files.
                        </p>
                        <p>Start your Python interpreter, or (optionally) open a Jupyter Notebook</p>
                        <p class="code-style"><pre><code>python</code></pre></p>
                        <p>Here's some code that you can copy-and-paste into your Python interpreter</p>
                        <p class="code-style"> <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sequence</span> <span style="color: #008800; font-style: italic"># import the binfpy sequence package</span>
<span style="color: #008800; font-style: italic"># here we load all reviewed sequences and create a dictionary which will allow us to recall each by its name</span>
findmyseq <span style="color: #666666">=</span> {}
seqs <span style="color: #666666">=</span> sequence<span style="color: #666666">.</span>readFastaFile(<span style="color: #BB4444">&#39;tpswb_reviewed.fa&#39;</span>, sequence<span style="color: #666666">.</span>Protein_Alphabet, parse_defline<span style="color: #666666">=</span><span style="color: #AA22FF; font-weight: bold">False</span>)
<span style="color: #AA22FF">print</span>(<span style="color: #BB4444">&#39;Loaded&#39;</span>, <span style="color: #AA22FF">len</span>(seqs), <span style="color: #BB4444">&#39;sequences&#39;</span>)
<span style="color: #AA22FF; font-weight: bold">for</span> s <span style="color: #AA22FF; font-weight: bold">in</span> seqs:
    findmyseq[s<span style="color: #666666">.</span>name] <span style="color: #666666">=</span> s
<span style="color: #008800; font-style: italic"># next we load each of the sub-family specific FASTA files to collect the names of each sub-family</span>
subfamily <span style="color: #666666">=</span> [<span style="color: #BB4444">&#39;a&#39;</span>,<span style="color: #BB4444">&#39;b&#39;</span>,<span style="color: #BB4444">&#39;c&#39;</span>,<span style="color: #BB4444">&#39;d&#39;</span>,<span style="color: #BB4444">&#39;e&#39;</span>,<span style="color: #BB4444">&#39;f&#39;</span>] <span style="color: #008800; font-style: italic"># all sub-families</span>
subfnames <span style="color: #666666">=</span> {} <span style="color: #008800; font-style: italic"># a dictionary with names of members of each sub-family</span>
<span style="color: #AA22FF; font-weight: bold">for</span> f <span style="color: #AA22FF; font-weight: bold">in</span> subfamily:
    fseqs <span style="color: #666666">=</span> sequence<span style="color: #666666">.</span>readFastaFile(<span style="color: #BB4444">&#39;tps&#39;</span> <span style="color: #666666">+</span> f <span style="color: #666666">+</span> <span style="color: #BB4444">&#39;.fa&#39;</span>, sequence<span style="color: #666666">.</span>Protein_Alphabet, parse_defline<span style="color: #666666">=</span><span style="color: #AA22FF; font-weight: bold">False</span>)
    subfnames[f] <span style="color: #666666">=</span> []
    <span style="color: #AA22FF; font-weight: bold">for</span> s <span style="color: #AA22FF; font-weight: bold">in</span> fseqs:
        subfnames[f]<span style="color: #666666">.</span>append(s<span style="color: #666666">.</span>name)
    <span style="color: #AA22FF">print</span>(<span style="color: #BB4444">&#39;Loaded&#39;</span>, <span style="color: #AA22FF">len</span>(fseqs), <span style="color: #BB4444">&#39;sequences for sub-family tps&#39;</span> <span style="color: #666666">+</span> f)
<span style="color: #008800; font-style: italic"># finally we revisit the original sequence data to amend the name of those entries which belong to a sub-family</span>
<span style="color: #AA22FF; font-weight: bold">for</span> s <span style="color: #AA22FF; font-weight: bold">in</span> seqs:
    <span style="color: #AA22FF; font-weight: bold">for</span> f <span style="color: #AA22FF; font-weight: bold">in</span> subfamily:
        <span style="color: #AA22FF; font-weight: bold">if</span> s<span style="color: #666666">.</span>name <span style="color: #AA22FF; font-weight: bold">in</span> subfnames[f]:
            s<span style="color: #666666">.</span>info <span style="color: #666666">=</span> s<span style="color: #666666">.</span>info <span style="color: #666666">+</span> <span style="color: #BB4444">&#39; SF=&#39;</span> <span style="color: #666666">+</span> f <span style="color: #008800; font-style: italic"># add another field to the header-line</span>
            s<span style="color: #666666">.</span>name <span style="color: #666666">=</span> s<span style="color: #666666">.</span>name <span style="color: #666666">+</span> <span style="color: #BB4444">&#39;|Tps&#39;</span> <span style="color: #666666">+</span> f <span style="color: #008800; font-style: italic"># extend the sequence name (which is used later)</span>
            <span style="color: #AA22FF; font-weight: bold">break</span>
<span style="color: #008800; font-style: italic"># save the sequences as a new FASTA file</span>
sequence<span style="color: #666666">.</span>writeFastaFile(<span style="color: #BB4444">&#39;tpswb_v1.fa&#39;</span>, seqs)
</pre>
                       </p>

                        <p>Now we have a new FASTA file tpswb_v1.fa that we will use going forward.
                            Since we amended the actual name, it will appear in the alignment file and the tree file that are generated from it.</p>
                    </div>
                    <div class="step">
                        <h4>Align extant sequences</h4>
                        <p>Let's perform the alignment, here with MAFFT:</p>
                        <p class="code-style"><pre><code>mafft --genafpair --maxiterate 1000 --reorder tpswb_v1.fa > tpswb_v1.aln</code></pre></p>
                        <p>We found that MAFFT performed best, but if you are curious here is the command you would use with Clustal Omega:</p>
                        <p class="code-style"><pre><code>clustalo -i tpswd_v1.fa -o tpswb_v1.aln --output-order=tree-order</code></pre></p>
                        <p>Either tool will perform the multiple sequence alignment and save it to "tpswb_v1.aln" in the same directory.
                            By default, both tools use the FASTA format, with an additional "gap" character.
                            The switch "--output-order=tree-order" ensures that sequences are ordered so that they agree with how they are likely grouped in a phylogenetic analysis.</p>
                    </div>
                    <div class="step">
                        <h4>Review alignment</h4>
                        <p>
                            Start AliView and load the alignment file (tpswb_v1.aln).
                            Look at it and ask if it successfully captures homologous regions amongst members.
                            Conversely, consider it the alignment accurately separates sections that are not homologous.
                            It is not unusual to see fragmentation at the termini, especially in light of selective presence of protein translocation signals.
                            Fragmentation within the core areas of the alignment can be dubious, and we should consider sources of support for them; if there is little, we may want to exclude the sequence/s.
                        </p>
                        <p>
                            In binfpy there is a function that will take a whole alignment and determine an "outlier" score for each sequence.
                            Each column \(i\) in an alignment with \(m\) sequences has \(N_i^{G}\) gaps and \(N_i^{C}\) non-gap characters.
                            The outlier score of a sequence within this alignment is
                            \(\sum_i -log(log_m N_i^{x_i})
                            \) where \(x_i\) is either \(G\) or \(C\), if the sequence has a gap or a non-gap character, respectively, at column \(i\).
                            This entropy-based score is small for sequences which conform with the consensus state (whichever it is) and large for sequences that stray from it.
                            One possibility is to use this score to evaluate each reviewed sequence when aligned against all of the other sequences, including the unreviewed ones.
                            That way, we evaluate the extent to which they are outliers in a broader sense than if we were to look at them only in the context of the smaller, reviewed-only alignment.
                        </p>
                        <p>To carry out this initial filtering, align the complete set of terpene synthases (tpswb_all.fa); then run the following code.</p>
                        <p class="code-style">
<!-- HTML generated using hilite.me -->
                        <pre style="margin: 0; line-height: 125%"><span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sequence</span>
<span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #AA22FF; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
aln <span style="color: #666666">=</span> sequence<span style="color: #666666">.</span>Alignment(sequence<span style="color: #666666">.</span>readFastaFile(<span style="color: #BB4444">&#39;tpswb_all.aln&#39;</span>, alphabet<span style="color: #666666">=</span>sequence<span style="color: #666666">.</span>Protein_Alphabet, gappy<span style="color: #666666">=</span><span style="color: #AA22FF; font-weight: bold">True</span>, ignore<span style="color: #666666">=</span><span style="color: #AA22FF; font-weight: bold">True</span>, parse_defline<span style="color: #666666">=</span><span style="color: #AA22FF; font-weight: bold">False</span>))
y, g, ins <span style="color: #666666">=</span> aln<span style="color: #666666">.</span>outliers()
ys <span style="color: #666666">=</span> np<span style="color: #666666">.</span>argsort(y)
keep <span style="color: #666666">=</span> []
<span style="color: #AA22FF; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> ys: <span style="color: #008800; font-style: italic"># go through each entry in the bigger alignment in ascending order of an aggregated outlier score</span>
    <span style="color: #AA22FF; font-weight: bold">if</span> aln[i]<span style="color: #666666">.</span>name <span style="color: #AA22FF; font-weight: bold">in</span> findmyseq:
        <span style="color: #AA22FF; font-weight: bold">if</span> y[i] <span style="color: #BB4444">&lt;</span> <span style="color: #666666">268</span>:
            <span style="color: #AA22FF">print</span>(<span style="color: #BB4444">&#39;Keep</span><span style="color: #BB6622; font-weight: bold">\t</span><span style="color: #BB4444">&#39;</span>, findmyseq[aln[i]<span style="color: #666666">.</span>name]<span style="color: #666666">.</span>name, <span style="color: #BB4444">&#39;</span><span style="color: #BB6622; font-weight: bold">\t</span><span style="color: #BB4444">&#39;</span>, y[i])
            keep<span style="color: #666666">.</span>append(aln[i]<span style="color: #666666">.</span>name)
        <span style="color: #AA22FF; font-weight: bold">else</span>:
            <span style="color: #AA22FF">print</span>(<span style="color: #BB4444">&#39;Bin</span><span style="color: #BB6622; font-weight: bold">\t</span><span style="color: #BB4444">&#39;</span>, findmyseq[aln[i]<span style="color: #666666">.</span>name]<span style="color: #666666">.</span>name, <span style="color: #BB4444">&#39;</span><span style="color: #BB6622; font-weight: bold">\t</span><span style="color: #BB4444">&#39;</span>, y[i])
            <span style="color: #AA22FF">print</span>(<span style="color: #BB4444">&#39;Total kept:&#39;</span>, <span style="color: #AA22FF">len</span>(keep))
filtered <span style="color: #666666">=</span> []
<span style="color: #AA22FF; font-weight: bold">for</span> sname <span style="color: #AA22FF; font-weight: bold">in</span> findmyseq:
    s <span style="color: #666666">=</span> findmyseq[sname]
    <span style="color: #AA22FF; font-weight: bold">if</span> sname <span style="color: #AA22FF; font-weight: bold">in</span> keep:
        filtered<span style="color: #666666">.</span>append(s)
sequence<span style="color: #666666">.</span>writeFastaFile(<span style="color: #BB4444">&#39;tpswb_v2.fa&#39;</span>, filtered)
</pre>
                        </p>
                        <p>Note that we used a threshold "268" at which a sequence would be binned as an outlier.
                            This value could be changed to be more or less sensitive to your expert taste;
                            keep an eye on what the sequences that you filter out look like in the original alignment (tpswb_v1.aln).
                        </p>
                    </div>
                        <h4>Re-align extant sequences</h4>
                        <p>Perform the alignment again, here with MAFFT as before:</p>
                        <p class="code-style"><pre><code>mafft --genafpair --maxiterate 1000 --reorder tpswb_v2.fa > tpswb_v2.aln</code></pre></p>
                        <p>
                        At this stage, we recommend that you use AliView to inspect and edit the alignment.
                        From this, it may be clear that sequences are placed poorly in the tree, suggesting that they are not aligned properly.
                        It is also possible that some sequences cannot be adequately analysed, due to limitations in evolutionary models etc.
                        For instance, larger re-arrangements can cause major problems, and in many instances it may be better to manually edit the alignment and/or exclude sequences entirely.
                        Needless to say, make sure to record changes you make, and re-run alignment.
                            In our case, we saved the alignment after removing a few sequences with long insertions, and little overlap with other sequences;
                            from within AliView we saved the new alignment as tpswb_v2_edited.aln and re-ran MAFFT on it to create tpswb_v3.aln.
                        </p>
                    <p class="code-style"><pre><code>mafft --genafpair --maxiterate 1000 --reorder tpswb_v2_edited.aln > tpswb_v3.aln</code></pre></p>

                    <p>
                        This may need to be done repeatedly, until you are happy that the alignment.
                            The inference of a phylogenetic tree later will shed further light on evolutionary relationships, so you may need to come back here again.
                        </p>
                </div>
                <div class="step">
                    <h4>Filtering your sequences in light of alignment</h4>
                    <p>
                        Another useful trick to make sure that your alignment is of good quality is to ensure your sequences contain previously known motifs, and that they are aligned.
                        We found a couple in Driller et al. (2018) and Schrepfer et al. (2016) that we filter for below.
                        The criteria is that, for each sequence in the alignment, at least one (of three) motif needs to match the most commonly occupied column for it.
                        We have provided some Python code to identify the sequences that do not conform to that criteria below.
                    </p>
                    <div>
                    <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #888888"># Read in the alignment file</span>
aln <span style="color: #333333">=</span> sequence<span style="color: #333333">.</span>readFastaFile(<span style="background-color: #fff0f0">&#39;tpswb_v3.aln&#39;</span>, alphabet<span style="color: #333333">=</span>sequence<span style="color: #333333">.</span>Protein_Alphabet, gappy<span style="color: #333333">=</span><span style="color: #007020">True</span>, ignore<span style="color: #333333">=</span><span style="color: #007020">True</span>, parse_defline<span style="color: #333333">=</span><span style="color: #007020">False</span>)
ali <span style="color: #333333">=</span> sequence<span style="color: #333333">.</span>Alignment(aln)
<span style="color: #888888"># Define motifs, here taken from Driller et al. (2018) and Schrepfer et al. (2016)</span>
motifs <span style="color: #333333">=</span> [sequence<span style="color: #333333">.</span>Regexp(<span style="background-color: #fff0f0">&quot;[D][DGE].{1,3}[DE]&quot;</span>),
          sequence<span style="color: #333333">.</span>Regexp(<span style="background-color: #fff0f0">&quot;[ND]D..[ST]...[ED]&quot;</span>),
          sequence<span style="color: #333333">.</span>Regexp(<span style="background-color: #fff0f0">&quot;W.{5,7}RY&quot;</span>)]
<span style="color: #888888"># Create a dictionary for each motif, </span>
<span style="color: #888888"># which associates columns with a match to the number of sequences with that match</span>
hits <span style="color: #333333">=</span> <span style="color: #007020">dict</span>()
best_hits <span style="color: #333333">=</span> <span style="color: #007020">dict</span>()
<span style="color: #008800; font-weight: bold">for</span> m <span style="color: #000000; font-weight: bold">in</span> motifs:
    hits[m] <span style="color: #333333">=</span> <span style="color: #007020">dict</span>() <span style="color: #888888"># key: column in alignment, value: count</span>
<span style="color: #008800; font-weight: bold">for</span> a <span style="color: #000000; font-weight: bold">in</span> ali:
    <span style="color: #008800; font-weight: bold">for</span> m <span style="color: #000000; font-weight: bold">in</span> motifs:
        result <span style="color: #333333">=</span> m<span style="color: #333333">.</span>search(a, gappy<span style="color: #333333">=</span><span style="color: #007020">True</span>)
        <span style="color: #008800; font-weight: bold">for</span> r <span style="color: #000000; font-weight: bold">in</span> result:
            <span style="color: #008800; font-weight: bold">if</span> <span style="color: #000000; font-weight: bold">not</span> r[<span style="color: #0000DD; font-weight: bold">0</span>] <span style="color: #000000; font-weight: bold">in</span> hits[m]:
                hits[m][r[<span style="color: #0000DD; font-weight: bold">0</span>]] <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>
            hits[m][r[<span style="color: #0000DD; font-weight: bold">0</span>]] <span style="color: #333333">=</span> hits[m][r[<span style="color: #0000DD; font-weight: bold">0</span>]] <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>
<span style="color: #888888"># Sort the columns by value (higher count first) and </span>
<span style="color: #888888"># save the top ranked column for each motif</span>
sorted_hits <span style="color: #333333">=</span> <span style="color: #007020">dict</span>()
<span style="color: #008800; font-weight: bold">for</span> m <span style="color: #000000; font-weight: bold">in</span> hits:
    sorted_hits[m] <span style="color: #333333">=</span> <span style="color: #007020">sorted</span>(hits[m]<span style="color: #333333">.</span>items(), key<span style="color: #333333">=</span><span style="color: #008800; font-weight: bold">lambda</span> kv: kv[<span style="color: #0000DD; font-weight: bold">1</span>], reverse<span style="color: #333333">=</span><span style="color: #007020">True</span>)
    best_hits[m] <span style="color: #333333">=</span> sorted_hits[m][<span style="color: #0000DD; font-weight: bold">0</span>][<span style="color: #0000DD; font-weight: bold">0</span>]
<span style="color: #888888"># Go through the alignment and &quot;keep&quot; sequences that fulfil the criteria below</span>
keep <span style="color: #333333">=</span> []
<span style="color: #008800; font-weight: bold">for</span> a <span style="color: #000000; font-weight: bold">in</span> ali:
    count_matches <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>
    <span style="color: #008800; font-weight: bold">for</span> m <span style="color: #000000; font-weight: bold">in</span> motifs:
        match <span style="color: #333333">=</span> <span style="color: #007020">False</span>
        result <span style="color: #333333">=</span> m<span style="color: #333333">.</span>search(a, gappy<span style="color: #333333">=</span><span style="color: #007020">True</span>)
        <span style="color: #008800; font-weight: bold">for</span> r <span style="color: #000000; font-weight: bold">in</span> result:
            <span style="color: #008800; font-weight: bold">if</span> r[<span style="color: #0000DD; font-weight: bold">0</span>] <span style="color: #333333">==</span> best_hits[m]:
                match <span style="color: #333333">=</span> <span style="color: #007020">True</span>
        <span style="color: #008800; font-weight: bold">if</span> match:
            count_matches <span style="color: #333333">+=</span> <span style="color: #0000DD; font-weight: bold">1</span>
    <span style="color: #008800; font-weight: bold">if</span> count_matches <span style="color: #333333">&lt;</span> <span style="color: #0000DD; font-weight: bold">1</span>: <span style="color: #888888"># criteria: at least one motif needs to be in place</span>
        <span style="color: #008800; font-weight: bold">print</span>(<span style="background-color: #fff0f0">&#39;Failed:&#39;</span>, a<span style="color: #333333">.</span>name)
    <span style="color: #008800; font-weight: bold">else</span>:
        keep<span style="color: #333333">.</span>append(a)
<span style="color: #888888"># Save the new alignment, which needs to be re-aligned</span>
sequence<span style="color: #333333">.</span>writeFastaFile(<span style="background-color: #fff0f0">&#39;tpswb_v4.aln&#39;</span>, keep)
</pre></div>
                    <p>
                        Now re-align this alignment since we took out some sequences.
                    </p>
                    <p class="code-style"><pre><code>mafft --genafpair --maxiterate 1000 --reorder tpswb_v4.aln > tpswb_v5.aln</code></pre></p>
                </div>
                    <div class="step">
                        <h4>Infer phylogenetic tree</h4>
                        <p>Run a phylogenetic tree inference program on the alignment to generate a tree. This usually takes a few minutes, if not hours, depending on size of data set, and type of program.
                            FastTree will infer a tree for almost 300 terpene synthases in less than a minute though. RaxML will take an hour or so.</p>
                        <p class="code-style"><pre><code>FastTree -out tpswb_v5.nwk tpswb_v5.aln</code></pre></p>
                    </div>
                    <div class="step">
                        <h4>Review phylogenetic tree</h4>
                        <p>Start Archaeopteryx and load the alignment file using the menu that appears.</p>
                        <p class="code-style"><pre><code>Archaeopteryx</code></pre></p>
                        <p>The first issue we need to resolve is to place the root of the tree correctly.</p>
                        <p>The basic tutorial used an outgroup, i.e. an additional homologous sequence (or set of sequences) that most probably would have diverged prior to the other family members.
                        From prior expertise, we are thus able to identify the branch on which the ancestor of that earlier evolutionary event would be placed.
                            As a consequence, we would know what branch point represents the ancestor of the members of interest. In our case, we expect bacterial members to be an outgroup.
                            </p>
                        <p>For the terpene synthases, we refer to a previous phylogenetic analysis, which identified the relationship between six sub-families (Tpsa-Tpsf; Bohlmann et al. 1998).
                        Since we extended sequence names with that information in the original FASTA file, this info is now available for searching in our tree.
                            Fortunately, Archaeopteryx provides a SEARCH function (see Figure 1).
                        Once you have placed the root where it identifies an ancestor from which the sub-classes originate, in a reasonable manner, save it to a new file, tpswb_v5r.nwk.
                        Before you save, also make sure that the bacterial sequences are separated at the root or close to it. (Tip: SEARCH for "_STR" will pick up identifiers for bacterial species.)</p>
                        <a id="tree_howtoroot-img"></a>
                        <div class="col-xs-12" style="height: 400px;">
                            <div class="img" style="height: 400px;" id="workshop_tps-nwk-img-div"></div>
                        </div>
                        <figcaption class="figure-caption">Figure 1.
                            Archaeopteryx offers dual search fields (1), type "Tpsa" and "Tpsb" to search for entries with those two words, to be highlighted in two colours.
                            Note that the inferred tree has an arbitrary root set, and may therefore show entries from the two sub-families ina disjointed manner (2).
                            (The tree here does <i>not</i> include bacterial sequences; you expect them to be an outgroup to the eukaryotic members.)
                            Find the point where the root should be for the sub-families to separate correctly,
                            by first consulting with Bohlmann et al. (1998) then activating the "Root/Reroot" function, and clicking on a branch point (3).
                        </figcaption>
                    </div>
                    <div class="step">
                        <h4>Consider filtering the sequence set, re-aligning and inferring a new tree</h4>

                    </div>
                    <div class="step">
                        <h3>Infer and explore ancestors</h3>
                        <p>
                            The TPSa family consists of angiosperm terpene synthases,
                            the TPSb family contains angiosperm monoterpene synthases,
                            TPSd of gymnosperm monoterpene synthases and TPSg Antirrhinum majus monoterpene synthases also share a common evolutionary origin (Bohlmann et al. 1998).
                            The gymnosperm terpene synthases have been subdivided into three distinct clades— TPS-d1 to TPS-d3.
                        </p>
                        <p>Here are some enzymes of interest:</p>
                        <p>Taxadiene synthase TDC1 from <i>Taxus brevifolia</i> is <a href="https://www.uniprot.org/uniprot/Q41594">Q41594</a>.
                        </p>
                        <p>Beta-eudesmol synthase ZSS2 from <i>Zingiber zerumbet</i> is <a href="https://www.uniprot.org/uniprot/B1B1U4">B1B1U4</a>.
                        </p>
                        <p>Cyclooctat-9-en-7-ol synthase CotB2
                            from <i>Streptomyces melanosporofaciens</i> is <a href="https://www.uniprot.org/uniprot/C9K1X5">C9K1X5</a>.
                        </p>

                        <div class="step">
                            <p>If you skipped the practical data curation steps, or had had issues them, download the alignment and tree from <a href="/download-workshop_tps-files">here</a>.</p>
                        </div>
                        <div class="step">
                            <h4>Perform the reconstruction using GRASP</h4>
                            <p>Run the final alignment and tree through <a href="http://grasp.scmb.uq.edu.au/">GRASP</a>.</p>
                            <p>
                            On the main page,
                                you can create a user account (if you have not done this already).</p>
                            <p>
                                To perform a reconstruction, input a name for it (needs to be unique),
                                the name of the alignment file (either FASTA or Clustal format)
                                and the phylogenetic tree file (in Newick format).
                                It is also best to switch "Save or Run" to "Save with email"; that way all the functionality will be available to you as soon as an
                                email alerts you to that the reconstruction is complete.
                                (If you don't select this option before you click "Perform reconstruction", you can just wait for it to complete in front of you, and then click save once finished.)
                            </p>
                        </div>
                        <div class="step">
                            <h4>Inspect the reconstructed ancestors</h4>
                            <p>Explore GRASP</p>
                            <p class="col-xs-4"> Under Tree Vis Options, click Annotate Taxonomy.</p>
                            <p class="col-xs-8">
                                This will get the taxonomic information for the sequences.
                                <em>Note:
                                    taxonomic information will only be displayed if the input sequences are labelled with the NCBI or Uniprot identifier (as in this tutorial).</em>
                            </p>
                            <p>
                                Under Tree Search Options, type in "bacteria" in the first text-field, and a fairly significant part of the tree will be highlighted.
                                The search function in GRASP will pick up words that are used in identifiers, and taxonomic annotations for sequences at the leaves of the tree.
                            </p>
                            <p>We will now focus on a protein of interest. This can be changed as you wish, but let's say we are interested in the terpene eudesmol,
                                and we would want to find which enzymes that are somehow related to its production; so we use Uniprot again:</p>
                            <p class="code-style"><pre><code>taxonomy:"Eukaryota [2759]" family:"terpene synthase family" eudesmol</code></pre></p>
                            <p>This should return at least one protein which is in our data set, namely "B1B1U4";
                                search for it in GRASP (click "Tree search options") and it will be highlighted in the tree.</p>
                            <p>Now try another protein, Taxadiene synthase also mentioned above, "Q41594".</p>
                            <p class="col-xs-4">Left-click on tree nodes</p>
                            <p class="col-xs-8">This will show any taxonomic information (if available) of the selected ancestor.
                                At ancestral nodes, this displays a summary of the taxonomic information for all child extant sequences.
                                Common ranks are listed, and a histogram is displayed for differing taxonomic information. Extant sequences (or leaf
                                nodes in the tree) show the full available taxonomic information for that extant.
                            </p>
                            <p>Do this for the immediate ancestor of Q41594, consider the taxonomic information and make a note of the node name.
                                Continue to do this for each ancestor until you reach N0. (In my recon they are N70, N69, N68, N66, N65, N47 and N0.)</p>
                            <p class="col-xs-4">Right-click on tree nodes</p>
                            <p class="col-xs-8">This will show a menu listing options for displaying the tree and performing further reconstructions.
                                From this menu, we can collapse and expand the tree nodes, perform a joint or marginal reconstruction, or add a joint
                                reconstruction graph that will be displayed below the current joint reconstruction.
                                See <a href="http://grasp.scmb.uq.edu.au/guide#results-phylo-nav">the guide</a> for more details.</p>
                            <p class="col-xs-4">Inspect the reconstructed ancestral partial-order graph (POG)</p>
                            <p class="col-xs-8">At the bottom of the page you will see at least two POGs. The top graph is the alignment graph (also referred to as MSA as it derives directly
                                from the input multiple sequence alignment), and the bottom
                                graph/s are the reconstructed ancestor graphs. You will see N0 by default. </p>
                                <p>Hovering over the graph nodes will display a popup showing a histogram of the characters in the
                                    alignment POG and in a marginal reconstruction POG. More information about these nodes can be found <a href="http://grasp.scmb.uq.edu.au/guide#po-graph-nav">in the guide</a>.</p>
                                <p>We can navigate across the reconstructed graph/s by sliding the purple rectangle along the navigation line above the (MSA) POAG.</p>
                            <p>Optionally, go through each of the nodes from N47 to the protein of interest (e.g. Q41594), now right-click and "Add joint reconstruction" for each node, in order of evolutionary time.
                                Each time, a new ancestor POG will appear below. Eventually you will need to scroll down to see them.</p>
                        </div>
                        <div class="step">
                            <h4>Investigate changes from N0 to a protein of interest</h4>
                            <p>Now let's use GRASP to explore differences between a set of ancestors, i.e. trace the predicted evolutionary events.
                                We are first taking a short-cut but note that if you followed the above (optional) instruction, you could use GRASP's interface to get a lot more detail.</p>
                            <p>Press the 'Download Results...' button underneath the reconstructed graphs, select 'Consensus sequence of joint reconstructions' and press the 'Download' button.
                                (There may be a brief delay until the file ends up on your computer.)</p>
                                <p>Consensus sequences only follow a single path so rather than a graph, the results you just downloaded is presented as a conventional multiple sequence alignment.
                                Load the file into AliView or other alignment viewer.
                                With AliView, you next highlight the sequences that you noted earlier (N0, N47 and so on to N70 for Q41594), "Copy selection as FASTA", and create a "New" alignment;
                                    in that new alignment, "Paste as FASTA sequences". Now your new alignment will only have the ancestors of Q41594.</p>
                                <p>Again in AliView, load the alignment file that contains the sequences that were input to GRASP (tpswb_v5.aln);
                                search for Q41594 and also include its neighbours in the phylogenetic tree. (Q93YA3 and Q9FT37 are both Taxadiene synthase for <i>Taxus baccata</i> and <i>wallichiana</i>, respectively.)                                Q0VHD6; copy and paste into your own alignment file, move them so they all are presented in chronological order N0 to your two extant sequences.
                            </p>
                            <p>You should now be able to follow all (predicted) substitutions from the ultimate terpene synthase ancestor, to the extant Taxadiene synthase Q41594 or the eudesmol synthase B1B1U4.
                                Now, ask questions about functional (or structural) sites of relevance. Do you know where the catalytic site is, in terms of sequence positions?</p>
                            <p>In our alignment, the three motifs we used above start at columns 976, 1174 and 1330, respectively. Check them out. Do you know of other relevant motifs?</p>
                                <p>While a sequence alignment can highlight regions of conservation, you now have access to the actual changes that led to the specific sequence, not only one site at a time, but across the whole protein.
                                Given that Nature may have already tested the ancestors out, imagine how you can use this to probe alternative constructs.
                            </p>
                        </div>
                        <div class="step">
                        <div class="step">
                            <h4>Explore insertions and deletions</h4>
                            <p>Above we converted each ancestor POG into a consensus sequence, but there may have been other histories of insertions and deletions that are possible. They are only available by looking in the POGs themselves.</p>
                            <p>If you have not already, try the sliding bar to navigate across positions along the POGs that are shown. You can change the size of the slider so that you see a larger (or smaller) part of all positions.
                            Solid edges are preferred (they are "bi-directionally" optimal), as are the darker ones (occupied by "more" extant sequences).
                            Refer to the <a href="http://grasp.scmb.uq.edu.au/guide">GRASP Guide</a> for more.</p>
                        </div>
                            <h4>Download the consensus sequence of the ancestors</h4>
                            <p>There are a few things that can be downloaded from your reconstruction, mostly more complex representations of the reconstruction
                                (refer to the <a href="http://grasp.scmb.uq.edu.au/guide">GRASP Guide</a>). Alternatively, you can save your reconstruction for later by pressing the blue disk
                                at the top left corner and following the prompts for creating an account with GRASP.
                                You can access the list of previously saved reconstructions by clicking your account name which will appear in the menu at the top right corner.</p>
                        </div>
                    </div>
                </div>

            <div class="cell border-box-sizing text_cell rendered">
                <div class="inner_cell">
                    <div class="text_cell_render border-box-sizing rendered_html">
                        <h2 id="refs-nav">References</h2>
                        <ol>
                            <li>Sievers F and Higgins DG (2018) Clustal Omega for making accurate alignments of many protein sciences. <i>Protein Sci</i>. 27:135-145. <a href="https://doi.org/10.1002/pro.3290">DOI</a>.</li>
                            <li>Price MN, Dehal PS and Arkin AP (2010) FastTree 2 -- Approximately Maximum-Likelihood Trees for Large Alignments. <i>PLoS ONE</i>. 5(3):e9490. <a href="https://doi.org/10.1371/journal.pone.0009490">DOI</a>.</li>
                            <li>Han MV and Zmasek CM (2009) phyloXML: XML for evolutionary biology and comparative genomics. <i>BMC Bioinformatics</i>. 10:356. <a href="https://doi.org/10.1186/1471-2105-10-356">DOI</a>.</li>
                            <li>Larsson A (2014) AliView: a fast and lightweight alignment viewer and editor for large data sets. <i>Bioinformatics</i>. 30(22): 3276-3278. <a href="http://dx.doi.org/10.1093/bioinformatics/btu531">DOI</a>.</li>
                            <li>Bohlmann et al. (1998) Plant terpenoid synthases: Molecular biology and phylogenetic analysis. <i>PNAS</i>. Vol. 95, pp. 4126–4133.<a href="https://dx.doi.org/10.1073/pnas.95.8.4126">DOI</a>.</li>
                            <li>Schrepfer et al. (2016) Identification of amino acid networks governing catalysis in the closed complex of class I terpene synthases. <i>PNAS</i>. 113(8):E958-67.<a href="https://dx.doi.org/10.1073/pnas.1519680113">DOI</a>.</li>
                            <li>Driller et al. (2018) Towards a comprehensive understanding of the structural dynamics of a bacterial diterpene synthase during catalysis. <i>Nat Commun.</i>.  28;9(1):3971.<a href="https://dx.doi.org/10.1038/s41467-018-06325-8">DOI</a>.</li>
                        </ol>
                    </div>
                </div>
            </div>
        </div>
    </div>
    </div>


</body>

</html>