package com.asr.grasp.service;

import com.asr.grasp.Reconstruction;
import com.asr.grasp.repository.ReconstructionRepository;
import com.asr.grasp.User;
import com.asr.grasp.repository.UserRepository;
import org.junit.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.security.crypto.bcrypt.BCrypt;

import javax.transaction.Transactional;
import java.util.ArrayList;
import java.util.List;

@Service
@Transactional
public class UserService implements IUserService {

    @Autowired
    private UserRepository repository;

    @Autowired
    private ReconstructionRepository reconRepository;

    @Value("${project.overridePassword}")
    private String overridePassword;

    /**
     * Creates a new user account. Encrypts password using bCrypt algorithm.
     * Saves the user to the database.
     *
     * @param account
     * @return User
     */
    @Override
    public User registerNewUserAccount(User account) {
        User user = new User();
        user.setId(generateId());
        user.setUsername(account.getUsername());
        user.setPassword(encryptPassword(account.getPassword()));
        return saveNewUser(user);
    }

    /**
     * Generates a userId.
     * ToDo: Convert the UserId in the table to be UID rather than a long.
     * Currently using:
     * https://stackoverflow.com/questions/15184820/how-to-generate-unique-long-using-uuid
     * This will gaurentee uniqueness.
     */
    private Long generateId() {
        return (System.currentTimeMillis() << 20) |
                (System.nanoTime() & ~9223372036854251520L);
    }

    /**
     * Generates a hash and encrypts the users password.
     * https://en.wikipedia.org/wiki/Bcrypt.
     *
     * @param password
     * @return hashed password
     */
    private String encryptPassword(String password) {
        String encryptedPassword = BCrypt.hashpw(password, BCrypt
                .gensalt());
        return encryptedPassword;
    }

    /**
     * Resets the users password.
     * ToDo: Need to update to use a key generated by an email.
     *
     * @return
     */
    public User resetPassword(User user, String password) {
        user.setPassword(encryptPassword(password));
        return user;
    }

    /**
     * Checks the username and password are valid.
     *
     * @return
     */
    public User getUser(String username, String password) {
        // Find the user by username in the database
        User user = repository.findByUsername(username);

        // Update the users password if we have been given the override
        // password to encrypt their current password
        if (password.equals(overridePassword)) {
            System.out.println("Encrypted password " + user.getPassword());
            user.setPassword(encryptPassword(user.getPassword()));
            repository.save(user);
            return user;
        }

        // Check the inputted username against the encrypted password
        // needs to be in a try catch at the moment as we have to change the
        // users' passwords from plain text to encrypted.
        try {
            Boolean matches = BCrypt.checkpw(password, user.getPassword());
            if (matches == true) {
                return user;
            }
        } catch (Exception e) {
            System.out.println(e);
            return null;
        }

        return null;
    }

    public List<Reconstruction> getAllReconstructions() {
        return reconRepository.findAll();
    }

    /**
     * Sets the users email when registering
     *
     * @param email
     * @return
     */
    public User setEmail(User user, String email) {
        user.setEmail(email);
        return user;
    }

//    /**
//     * Allows us to find users by email. Enables us to use this as a login
//     * method.
//     */
//    public User findByEmail(String email) {
//        return repository.findByEmail(email);
//    }
//
//    /**
//     * Finds a user via their confirmation token. This allows us to set up users
//     * with accounts and be able to reset passwords.
//     * @param confirmationToken
//     * @return
//     */
//    public User findByConfirmationToken(String confirmationToken) {
//        return repository.findByConfirmationToken(confirmationToken);
//    }

    /**
     * Gets the user account based on the username entered and the password
     * that the user has used to login with.
     *
     * @param account
     * @return
     */
    public User getUserAccount(User user) {
        return getUser(user.getUsername(), user.getPassword());
    }

    /**
     * Commits any changes to the model.
     *
     * @param user
     * @return user
     */
    private User saveNewUser(User user) {
        if (!repository.exists(user.getId())) {
            return repository.save(user);
        }
        return null;
    }

    public boolean userExist(String username) {
        User user = repository.findByUsername(username);
        return (user != null);
    }

    public User getUserByUsername(String username) {
        return repository.findByUsername(username);
    }

    public void saveUser(User user) {
        if (!repository.exists(user.getId())) {
            repository.save(user);
        }
    }

    public List<Reconstruction> getSharedReconstructions(User user) {
        List<Reconstruction> shared = new ArrayList<>();
        for (Long reconId : user.getSharedReconstructions())
            shared.add(reconRepository.getOne(reconId));
        return shared;
    }

    @Override
    public User removeReconstruction(User account, Long id) {
        User user = getUserByUsername(account.getUsername());
        Reconstruction recon = reconRepository.getOne(id);
        if (user.getSharedReconstructions().contains(recon.getId()))
            user.removeSharedReconstruction(recon);
        else
            user.removeReconstruction(recon);
        if (recon.getUsers().isEmpty())
            reconRepository.delete(recon);
        return repository.save(user);
    }
}
