package com.asr.grasp.db;

import com.sun.org.apache.xpath.internal.operations.Bool;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.PreparedStatement;
import java.sql.ResultSet;

public class Users extends Base {

    /**
     * Tells us where we can expect each value for the results from the
     * database.
     */
    final int idIdx = 1;
    final int usernameIdx = 2;
    final int passwordIdx = 3;

    final String idCol = "id";
    final String usernameCol = "username";
    final String passwordCol = "password";

    public Users() {

    }

    /**
     * Creates a new user account. Encrypts password using bCrypt algorithm.
     * Saves the user to the database.
     *
     * @param account
     * @return User
     */
    public int registerUser(String username, String rawPassword) {
        String[] values = {username, encryptPassword(rawPassword)};
        // Check a user doesn't exist with that username
        if (getUserId(username) > 0) {
            // Usernames are unique.
            return -1;
         }
         if (!insertStrings("INSERT INTO USERS(username, password) " +
                "VALUES(?, ?);", values)) {
             return -1;
         }
         // Get the userId based on the unique username
        return getUserId(username);
    }

    /**
     * Generates a userId.
     * ToDo: Convert the UserId in the table to be UID rather than a long.
     * Currently using:
     * https://stackoverflow.com/questions/15184820/how-to-generate-unique-long-using-uuid
     * This will gaurentee uniqueness.
     */
    private Long generateId() {
        return (System.currentTimeMillis() << 20) |
                (System.nanoTime() & ~9223372036854251520L);
    }

    /**
     * Generates a hash and encrypts the users password.
     * https://en.wikipedia.org/wiki/Bcrypt.
     *
     * @param password
     * @return hashed password
     */
    private String encryptPassword(String password) {
        String encryptedPassword = BCrypt.hashpw(password, BCrypt
                .gensalt());
        return encryptedPassword;
    }

    /**
     * Resets the users password.
     * ToDo: Need to update to use a key generated by an email.
     *
     * @return
     */
    public Boolean resetPassword(int id, String newPassword) {
        try {
            ResultSet user = updateStringOnId("UPDATE USERS(password) VALUES" +
                    "(?) WHERE id=?;", id, newPassword);
            if (user.next()) {
                return true;
            }
            return false;
        } catch (Exception e) {

        }
        return user;
    }

    /**
     * Gets the user ID from the unique username.
     *
     * @param username
     * @return
     */
    public int getUserId(String username) {
        return getIdOnUniqueString("SELECT id FROM USERS WHERE username=?;",
                username);
    }

    public boolean deleteUser(String username) {
        // Also need to delete all the groups that this person owns and all
        // the reconstructions that they have.
        return false;
    }

    /**
     * Checks the username and password are valid.
     *
     * @return
     */
    public int loginUser(String username, String rawPassword) {
        try {
            // Find the user by username in the database
            ResultSet user = queryOnString("SELECT * FROM USERS WHERE " +
                    " username=?;", username);

            // Update the users password if we have been given the override
            String encryptedPassword = user.getString(passwordIdx);

            // Check the inputted username against the encrypted password
            // needs to be in a try catch at the moment as we have to change the
            // users' passwords from plain text to encrypted.

            Boolean matches = BCrypt.checkpw(rawPassword, encryptedPassword);

            if (matches == true) {
                return user.getInt(idIdx);
            }
        } catch (Exception e) {
            System.out.println(e);
            return -1;
        }

        return -1;
    }

}
