package com.asr.grasp.model;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import com.asr.grasp.utils.Defines;
import java.util.ArrayList;
import org.springframework.stereotype.Repository;
import org.springframework.security.crypto.bcrypt.BCrypt;

/**
 * Interface with the Postgres Database table Users
 *
 * Created by ariane on 13/07/18.
 */
@Repository
public class UsersModel extends BaseModel {

    /**
     * Tells us where we can expect each value for the results from the
     * model.
     */
    final ColumnEntry id = new ColumnEntry(1, "id", Defines.INT);
    final ColumnEntry username = new ColumnEntry(2, "username", Defines
            .STRING);
    final ColumnEntry password = new ColumnEntry(3, "password", Defines
            .STRING);

    /**
     * Creates a new user account. Encrypts password using bCrypt algorithm.
     * Saves the user to the model.
     *
     * @param
     * @return User
     */
    public String registerUser(String username, String email, String temporaryPassword) {
        temporaryPassword = encryptPassword(temporaryPassword);

        // Check a user doesn't exist with that username
        if (getUserId(username) > 0) {
            // Usernames are unique.
            return "user.username.duplicate";
        }
        String query = "INSERT INTO web.users(username, password, email) " +
                "VALUES(?, ?, PGP_SYM_ENCRYPT(?,'AES_KEY'));";
        Connection con = null;
        String result = null;
        try {
            con = DriverManager.getConnection(dbUrl, dbUsername,
                    dbPassword);
            PreparedStatement statement = con.prepareStatement(query);
            statement.setString(1, username);
            statement.setString(2, temporaryPassword);
            statement.setString(3, email);
            statement.executeUpdate();
        } catch (Exception e) {
            System.out.println("UNABLE TO INSTERT USER: " + username + e.getMessage());
            result = "user.username.error";
        }
        closeCon(con);
        return result;
    }

    /**
     * Returns a plain text version of a users password so that it can be used to send them
     * the forgot password token.
     *
     * @param userId
     * @return
     */
    public String getUsersEmail(int userId) {
        String query = "SELECT PGP_SYM_DECRYPT(email::bytea, 'AES_KEY') as email FROM web.users where id=?;";
        ResultSet result = queryOnId(query, userId);
        try {
            while (result.next()) {
                // There should only be one email
                return result.getString(1);
            }
        } catch (Exception e) {
            System.out.println("ERROR GETTING EMAIL" + e);
        }
        return null;
    }

    /**
     * Sets a users email. This is now done so that users can save their email to their account.
     *
     * @param userId
     * @return
     */
    public boolean setUsersEmail(int userId, String email) {
        String query = "UPDATE web.users SET email = PGP_SYM_ENCRYPT(?,'AES_KEY') WHERE id=?;";
        return updateStringOnId(query, userId, email);
    }

    /**
     * Creates a new user account. Encrypts password using bCrypt algorithm.
     * Saves the user to the model.
     *
     * TODO: DELETE this is legacy.
     *
     * @param
     * @return User
     */
//    public String registerUser(String username, String rawPassword) {
//        String[] values = {username, encryptPassword(rawPassword)};
//        // Check a user doesn't exist with that username
//        if (getUserId(username) > 0) {
//            // Usernames are unique.
//            return "user.username.duplicate";
//         }
//         if (!insertStrings("INSERT INTO web.users(username, password) " +
//                "VALUES(?, ?);", values)) {
//             return "user.username.error";
//         }
//        return null;
//    }

    /**
     * Generates a userId.
     * ToDo: Convert the UserId in the table to be UID rather than a long.
     * Currently using:
     * https://stackoverflow.com/questions/15184820/how-to-generate-unique-long-using-uuid
     * This will gaurentee uniqueness.
     */
    public Long generateId() {
        return (System.currentTimeMillis() << 20) |
                (System.nanoTime() & ~9223372036854251520L);
    }

    /**
     * Generates a hash and encrypts the users password.
     * https://en.wikipedia.org/wiki/Bcrypt.
     *
     * @param password
     * @return hashed password
     */
    private String encryptPassword(String password) {
        String encryptedPassword = BCrypt.hashpw(password, BCrypt.gensalt());
        return encryptedPassword;
    }


    /**
     * Resets the users password.
     * ToDo: Need to update to use a key generated by an email.
     *
     * @return
     */
    public String resetPassword(int id, String newPassword) {
        try {
            if (updateStringOnId("UPDATE web.users SET password=?" +
                    "WHERE id=?;", id, encryptPassword(newPassword))) {
                return null; // i.e. success
            }
            return "user.username.nonexist";
        } catch (Exception e) {
            System.err.println(e);
            // If we had an error here it means that we weren't able to reset
            // the user name thus the user must not exist
            return "user.username.nonexist";
        }
    }

    /**
     * Gets the user ID from the unique username.
     *
     * @param username
     * @return
     */
    public int getUserId(String username) {
        return getIdOnUniqueString("SELECT id FROM web.users WHERE " +
                        "username=?;",
                username);
    }

    /**
     * ToDo: We don't have the capabilities of deleting a user - probably
     * should add this.
     *
     * @param userId
     * @return
     */
    public boolean deleteUser(int userId) {
        // Also need to delete all the groups that this person owns and all
        // the reconstructions that they have.
        String queryDeleteShareUsers = "DELETE FROM web.share_users WHERE " +
                "u_id =?;";
        if (deleteOnId(queryDeleteShareUsers, userId) != true) {
            return false;
        }
        // We need to first get all reconstructions that the user owns so
        // we can delete all the associated consensus sequences.
        String queryGetReconIds = "SELECT id FROM web.reconstructions WHERE owner_id=?";
        ResultSet results = queryOnId(queryGetReconIds, userId);
        if (results != null) {
            ArrayList<Integer> reconIds = getIdList(results);
            // Delete all consensus seqs
            String queryDeleteConsensus = "DELETE FROM web.sequences where r_id=?;";
            for (Integer rId: reconIds) {
                if (!deleteOnId(queryDeleteConsensus, rId)) {
                    return false;
                }
            }
            String queryDeleteInferences = "DELETE FROM web.inferences where r_id=?;";
            for (Integer rId: reconIds) {
                if (!deleteOnId(queryDeleteInferences, rId)) {
                    return false;
                }
            }
            String queryDeleteRecon = "DELETE FROM web.reconstructions WHERE " +
                    "owner_id=?;";
            if (deleteOnId(queryDeleteRecon, userId) != true) {
                return false;
            }
        }
        String queryDeleteUser = "DELETE FROM web.users WHERE id=?;";
        if (deleteOnId(queryDeleteUser, userId) != true) {
            return false;
        }
        return true;
    }

    /**
     * Checks the username and password are valid.
     *
     * @return String for error message or null for success
     */
    public String loginUser(String username, String rawPassword) {
        try {
            // Find the user by username in the model
            ResultSet user = queryOnString("SELECT password, id FROM web" +
                    ".users " +
                    "WHERE" +
                    " username=?;", username);

            if (user.next()) {
                // Update the users password if we have been given the override
                String encryptedPassword = user.getString(password.getLabel());

                // We want to be able to update the passwords tmp
                if (encryptedPassword.equals(rawPassword)) {
                    // Update the users password
                    resetPassword(user.getInt(id.getLabel()), rawPassword);
                    return null;
                }
                // Check the inputted username against the encrypted password
                // needs to be in a try catch at the moment as we have to change the
                // users' passwords from plain text to encrypted.

                Boolean matches = BCrypt.checkpw(rawPassword, encryptedPassword);

                if (matches == true) {
                    // If there is no error i.e. the user correctly enters the
                    // password we return null.
                    return null;
                } else {
                    return "user.password.incorrect";
                }
            }
            return "user.username.nonexist";
        } catch (Exception e) {
            System.err.println(e);
            // The user musn't exist
            return "user.username.nonexist";
        }
    }

}
