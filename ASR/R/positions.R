#'Identify target positions for mutational analysis
#'
#'
#'@param asrStructure the named list returned by \code{\link{runASR}}, \code{\link{loadASR}} or \code{\link{reduce_alphabet}}. Set this to NULL
#'to specify other variables
#'@param max the maximum number of positions 
#'@param posFirst if TRUE, this limits possible combinations at a position to 2
#'@param distribDF option to provide the dataframe generated by \code{\link{read_distrib}} rather than use the asrStructure
#'
#'@return a dataframe with three columns representing the position, number of AAs and list of AAs to target for mutation
#' posDF$Position\cr
#' posDF$Mode\cr
#' posDF$AAs\cr
#' #Example\cr
#' posDF[1, ] = "186", "3", "H,C,N" - Position 186 is optimised at 3 positions and the top letters are H, C and N\cr
#' 
#' @examples
#' data(asrStructure)
#' 
#' find_positions(asrStructure)
#' find_positions(asrStructure, max = 50)
#' find_positions(asrStructure, max = 10, posFirst = TRUE)
#' 
#'#if you want to use a specific set of data
#'#retrieve example file stored in the package
#' id_distribution <- system.file("extdata", "runASR_distribution.txt", package="ASR")
#' #alternatively, specify the filename as a string
#' #id_distribution <- "id_distribution.txt"
#' 
#' distribDF <- read_distrib(NULL, distrib_file = id_distribution)
#' find_positions(NULL, distribDF = distribDF) #if you want to specify your own file
#'
#' @export


find_positions <- function(asrStructure, max = 20, posFirst=FALSE, distribDF=NULL) {
  
  distribProbs <- dfError(asrStructure, "distribProbs", distribDF, c("Column", "AA", "Probability"), "Marginal")
  
  pseudo = 2.2204E-16
  kl_div <- function(P, Q) {
    if (length(P) != length(Q)) {
      stop()
    }
    sum = 0.0
    for (i in seq(1, length(P), 1)) {
      if (P[i] != 0) {
        sum = sum + P[i] * log2((P[i] + pseudo)/(Q[i] + pseudo))
      }
    }
    if (sum < 0){
      print("Low")
    }
    sum
  }
  
  getQ <- function(P, n) {
    Q = rep(0, length(P))
    p = 1.0 / n
    idxP = sort(P, index.return=TRUE)[[2]]
    for (i in seq(1, n, 1)) {
      idx = idxP[length(idxP) + 1 - i]
      Q[idx] = p
    }
    Q
  }
  
  sumKL <- function(distrib,Ns) {
    sum = 0.0
    for (i in seq(1, length(levels(distrib$Column)), 1)) {
      P <- distrib[distrib$Column == i,]$Probability
      n = Ns[i]
      Q = getQ(P, n)
      sum = sum + kl_div(P, Q)
    }
    sum
  }
  
#   distribProbs <- asrStructure$distribProbs
  distribProbs <- distribProbs[!is.na(distribProbs$Probability), ] ##Remove NAs
  alphLen <- length(levels(as.factor(distribProbs$AA)))
  numPs <- length(levels(distribProbs$Column))
  Ns = rep(1, numPs)
  improv <- rep(0, numPs)
  kl_div_scores <- rep(0, numPs)
  # Initialise improvement values across all positions
  for (i in seq(1, numPs)) {
    P <- distribProbs[distribProbs$Column == i,]$Probability
    n = Ns[i]
    Q <- getQ(P, n)
    before <- kl_div(P, Q)    
    Q <- getQ(P, n + 1)
    after <- kl_div(P, Q)
    improv[i] = before - after
    kl_div_scores[i] <- before
  }
  
  #first exit point - take top x positions with 2 aa possibilities
  if (posFirst) {
    sorted = sort(improv, index.return=TRUE)[[2]]
    return(tail(sorted, max))
  }
  
  sorted = sort(improv, index.return=TRUE)[[2]]
  best_idx = sorted[length(improv)]
  positions <- rep(0, max)
  converge <- rep(FALSE, length(improv))
  j = 1
  while ((j <= max) && (any(converge == FALSE))) {
    positions[j] <- best_idx
    if (improv[best_idx] > 0) {
      Ns[best_idx] <- Ns[best_idx] + 1
      P <- distribProbs[distribProbs$Column == best_idx,]$Probability
      n <- Ns[best_idx] # get current N
      #Test whether updating n to next mode will create improvement
      Q <- getQ(P, n)
      before <- kl_div(P, Q)
      Q <- getQ(P, n + 1)
      after <- kl_div(P, Q)
      if ((before - after) > 0) {#if we see FURTHER improvement
        improv[best_idx] = before - after
        kl_div_scores[best_idx] = after
      } else { #reached max improvement in this position, need to look at next position
        kl_div_scores[best_idx] = before
        converge[best_idx] <- TRUE # we are finished with this position
      }
    } else {
      converge[best_idx] <- TRUE # we are finished with this position
    }
    sorted <- sort(improv, index.return=TRUE)[[2]]
    #Order convergence by improv then identify the position with the highest improv that has not converged
    best_idx <- tail(sorted[!converge[sorted]], 1) # best_index is the next highest position that HAS NOT converged
#     print(sum(kl_div_scores))
    j=j+1
  }
#   positions
  positions <- positions[positions != 0] #remove 0s from positions
  positions <- unique(positions) #get unique positions (preserves order)

  for (i in seq(1, length(positions), 1)) {
    pos <- positions[i]
    mode <- Ns[pos]
    dc <- distribProbs[distribProbs$Column==pos,]
    dp <- dc[order(dc$Probability),]
    aas <- paste(head(dp$AA, mode), collapse=",")
    if (i == 1) {
      m <- matrix(c(pos, mode, aas), ncol=3, nrow=1)
    } else {
      n <- matrix(c(pos, mode, aas), ncol=3, nrow=1)
      m <- rbind(m, n)
    }
  }
  df <- data.frame(m[,1], m[,2], m[,3])
  colnames(df) <- c("Position", "Mode", "AAs")
  df
}





















